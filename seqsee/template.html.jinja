<!-- template.html -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>{{ title }}</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/dreampulse/computer-modern-web-font@master/fonts.css" />
  <style>
    body {
      font-family: "Computer Modern Serif", serif;
      font-variant: small-caps;
      font-weight: 500;
      font-size: 20pt;
      margin: 0;
      overflow: hidden;
    }

    .katex {
      font-size: 1em !important;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: absolute;
    }

    #grid-path {
      stroke: #ccc;
      stroke-width: 1;
    }

/* Dynamically generated CSS styles */
{{ css_styles }}

    #tooltip {
      position: absolute;
      display: none;
      pointer-events: none;
      background-color: white;
      border: 1px solid black;
      padding: 5px;
      z-index: 10;
    }

    .axis {
      stroke: black;
      stroke-width: 2px;
    }

    .tick {
      stroke: black;
      stroke-width: 1px;
    }
  </style>
</head>

<body style="visibility: hidden">
  <div id="canvas-container">
    <svg id="svg-canvas" width="100%" height="100%">
      <defs>
        <!-- Define the arrowhead markers -->
        <marker id='arrow-simple' orient="auto" markerWidth='3' markerHeight='4' refX='0.1' refY='2' fill="context-fill"
          stroke="context-stroke">
          <path d='M0,0 V4 L2,2 Z' />
        </marker>
        <!-- Define the grid pattern -->
        <pattern id="grid" width="{{ 2*spacing }}" height="{{ 2*spacing }}" patternUnits="userSpaceOnUse">
          <path id="grid-path" d="M {{ 2*spacing }} 0 L 0 0 0 {{ 2*spacing }}" fill="none"/>
        </pattern>
      </defs>
      <g id="content-group" class="svg-pan-zoom_viewport">
        <!-- Apply the grid pattern to a large background rectangle -->
        <rect id="grid-background" width="{{ chart_width * spacing }}px" height="{{ chart_height * spacing }}px" fill="url(#grid)" />
        <!-- Write title in the top left corner -->
        <foreignObject id="title-container" x="{{spacing}}px" width="100%" height="100%">
          <div xmlns="http://www.w3.org/1999/xhtml" id="title">
            {{ data.header.title }}
          </div>
        </foreignObject>
        <!-- Nodes and Edges generated statically by Python -->
        {{ static_svg_content }}
      </g>
      <g id="axes-group">
        <!-- X-axis -->
        <line id="x-axis" class="axis" />
        <!-- Y-axis -->
        <line id="y-axis" class="axis" />
        <!-- Blocks under and to the left to hide the content -->
        <rect id="x-block" x="0" y="0" fill="white" />
        <rect id="y-block" x="0" y="0" fill="white" />
      </g>
    </svg>
  </div>
  <div id="tooltip"></div>
  <!-- Include KaTeX JS -->
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
  <!-- Include svg-pan-zoom Library -->
  <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>
  <script>
    (function () {
      var canvasHeight = document.documentElement.clientHeight;
      var canvasWidth = document.documentElement.clientWidth;
      const chartWidth = {{ chart_width }};
      const chartHeight = {{ chart_height }};
      const spacing = {{ spacing }};

      // Render title
      window.renderMathInElement(document.getElementById("title"), {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ],
        // â€¢ rendering keys, e.g.:
        throwOnError : false
      });

      // Scale and position title
      const bBox = document.getElementById("title").getBoundingClientRect();
      const titleContainer = document.getElementById("title-container");
      titleContainer.setAttribute("width", (chartHeight - 2) * spacing);
      titleContainer.setAttribute("height", bBox.height);
      const nonInvertedY = (chartHeight - 1) * spacing + bBox.height / 2
      titleContainer.setAttribute("y", canvasHeight - nonInvertedY);

      // Adjust y-values for all elements in content-group
      document
        .querySelectorAll("#content-group line, #content-group circle")
        .forEach((element) => {
          if (element.tagName === "line") {
            const y1 = parseFloat(element.getAttribute("y1"));
            const y2 = parseFloat(element.getAttribute("y2"));
            element.setAttribute("y1", canvasHeight - y1);
            element.setAttribute("y2", canvasHeight - y2);
          } else if (element.tagName === "circle") {
            const cy = parseFloat(element.getAttribute("cy"));
            element.setAttribute("cy", canvasHeight - cy);
          }
        });

      // Adjust y-value for grid transformation
      document
        .getElementById("grid-background")
        .setAttribute(
          "transform",
          `scale(1 -1) translate(0 -${canvasHeight})`
        );

      const axisSpacing = 0.6 * spacing;

      // Put in end values for axes and apply y-flip
      document
        .querySelectorAll("#axes-group line")
        .forEach((element) => {
          if (element.id === "x-axis") {
            element.setAttribute("x1", axisSpacing);
            element.setAttribute("y1", canvasHeight - axisSpacing);
            element.setAttribute("x2", canvasWidth);
            element.setAttribute("y2", canvasHeight - axisSpacing);
          } else if (element.id === "y-axis") {
            element.setAttribute("x1", axisSpacing);
            element.setAttribute("y1", canvasHeight - axisSpacing);
            element.setAttribute("x2", axisSpacing);
            element.setAttribute("y2", 0);
          }
        });

      // Do the same for axis blocks
      document
        .querySelectorAll("#axes-group rect")
        .forEach((element) => {
          const offset = axisSpacing;

          if (element.id === "x-block") {
            element.setAttribute("width", canvasWidth);
            element.setAttribute("height", offset);
            element.setAttribute("y", canvasHeight - offset);
          } else if (element.id === "y-block") {
            element.setAttribute("width", offset);
            element.setAttribute("height", canvasHeight);
          }
        });

      function onResize() {
        const newCanvasHeight = document.documentElement.clientHeight;
        const newCanvasWidth = document.documentElement.clientWidth;
        const yOffset = newCanvasHeight - canvasHeight;

        // Adjust y-values for all elements in content-group
        document
          .querySelectorAll("#content-group line, #content-group circle")
          .forEach((element) => {
            if (element.tagName === "line") {
              const y1 = parseFloat(element.getAttribute("y1"));
              const y2 = parseFloat(element.getAttribute("y2"));
              element.setAttribute("y1", y1 + yOffset);
              element.setAttribute("y2", y2 + yOffset);
            } else if (element.tagName === "circle") {
              const cy = parseFloat(element.getAttribute("cy"));
              element.setAttribute("cy", cy + yOffset);
            }
          });

        // Adjust y-value for grid transformation
        document
          .getElementById("grid-background")
          .setAttribute(
            "transform",
            `scale(1 -1) translate(0 -${newCanvasHeight})`
          );

        // Put in end values for axes and apply y-flip
        document
          .querySelectorAll("#axes-group line")
          .forEach((element) => {
            if (element.id === "x-axis") {
              element.setAttribute("y1", newCanvasHeight - axisSpacing);
              element.setAttribute("x2", newCanvasWidth);
              element.setAttribute("y2", newCanvasHeight - axisSpacing);
            } else if (element.id === "y-axis") {
              element.setAttribute("y1", newCanvasHeight - axisSpacing);
            }
          });

        // Do the same for axis blocks
        document
          .querySelectorAll("#axes-group rect")
          .forEach((element) => {
            const offset = axisSpacing;

            if (element.id === "x-block") {
              element.setAttribute("width", newCanvasWidth);
              element.setAttribute("y", newCanvasHeight - offset);
            } else if (element.id === "y-block") {
              element.setAttribute("height", newCanvasHeight);
            }
          });

        // Adjust title position
        const titleContainer = document.getElementById("title-container");
        titleContainer.setAttribute("y", newCanvasHeight - nonInvertedY);
        
        // Reset pan, then pan slightly so the origin is visible
        window.panZoom.resetPan();
        window.panZoom.panBy({ x: (2 * 0.6) * spacing, y: -(2 * 0.6) * spacing });

        canvasHeight = newCanvasHeight;
        canvasWidth = newCanvasWidth;
      }
      window.addEventListener("resize", onResize);

      // Initialize svg-pan-zoom for panning and zooming
      window.panZoom = svgPanZoom("#svg-canvas", {
        zoomEnabled: true,
        fit: false,
        center: false,
        minZoom: 0.1,
        maxZoom: 10,
        panEnabled: true,
      });

      onResize();

      // Add hover events to nodes for tooltips
      document.querySelectorAll("circle").forEach((node) => {
        node.addEventListener("mouseover", function (event) {
          const label = this.getAttribute("data-label");
          if (label) {
            const renderedLabel = katex.renderToString(label, {
              throwOnError: false,
            });
            tooltip.innerHTML = renderedLabel;
            tooltip.style.display = "block";
          }
        });
        node.addEventListener("mousemove", function (event) {
          tooltip.style.left = event.clientX + 10 + "px";
          tooltip.style.top = event.clientY + 10 + "px";
        });
        node.addEventListener("mouseout", function (event) {
          tooltip.style.display = "none";
        });
      });

      // Show the SVG after y-values are adjusted
      document.body.style.visibility = "visible";
    }) ();
  </script>
</body>

</html>